#version 330 core

struct Material
{
    sampler2D ambient_specular_texture;  // Texture used for both ambient and specular
    sampler2D diffuse_texture;
    float shininess;
};

struct point_light_source
{
    vec3 position;
    vec3 ambient_color;
    vec3 diffuse_color;
    vec3 specular_color;

    float constant;
    float linear;
    float quadratic;
    int enabled;
};

struct dir_light_source
{
    vec3 direction;
    vec3 ambient_color;
    vec3 diffuse_color;
    vec3 specular_color;
    int enabled;
};

const int MAX_LIGHTS = 16;
uniform Material material;
uniform int point_lights;
uniform int dir_lights;
uniform point_light_source point_sources[MAX_LIGHTS];
uniform dir_light_source dir_sources[MAX_LIGHTS];
uniform vec3 camera_position;
uniform float mix_percentage;
in vec3 normal;
in vec3 frag_pos;
in vec2 frag_tex_coords;

void main()
{
    vec3 result = vec3(0.0);

    vec3 texture_color1 = texture(material.ambient_specular_texture, frag_tex_coords).rgb;
    vec3 texture_color2 = texture(material.diffuse_texture, frag_tex_coords).rgb;
    vec3 final_color = mix(texture_color1, texture_color2, mix_percentage);
    
    vec3 ambient_color = final_color;
    vec3 specular_color = final_color;
    vec3 diffuse_color = final_color;

    int delimiter = (point_lights < MAX_LIGHTS) ? point_lights : MAX_LIGHTS;
    for(int i = 0; i < delimiter; i++)
    {
        point_light_source light = point_sources[i];
        if(light.enabled != 1){
            continue;
        }
        vec3 lightDir;
        float attenuation = 1.0;
        lightDir = normalize(light.position - frag_pos);
        float dist = length(light.position - frag_pos);
        attenuation = 1.0 / (light.constant + light.linear * dist + light.quadratic * dist * dist);
        
        // Ambient
        vec3 ambient = light.ambient_color * ambient_color;

        // Diffuse
        float diff = max(dot(normalize(normal), lightDir), 0.0);
        vec3 diffuse = diff * light.diffuse_color * diffuse_color;

        // Specular
        vec3 viewDir = normalize(camera_position - frag_pos);
        vec3 reflectDir = reflect(-lightDir, normalize(normal));
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
        vec3 specular = spec * light.specular_color * specular_color;

        ambient *= attenuation;
        diffuse *= attenuation;
        specular *= attenuation;

        result += ambient + diffuse + specular;
    }

    delimiter = (dir_lights < MAX_LIGHTS) ? dir_lights : MAX_LIGHTS;
    for(int i = 0; i < delimiter; i++)
    {
        dir_light_source light = dir_sources[i];
        if(light.enabled != 1){
            continue;
        }
        vec3 lightDir;
        float attenuation = 1.0;
        lightDir = normalize(-light.direction);

        // Ambient
        vec3 ambient = light.ambient_color * ambient_color;

        // Diffuse
        float diff = max(dot(normalize(normal), lightDir), 0.0);
        vec3 diffuse = diff * light.diffuse_color * diffuse_color;

        // Specular
        vec3 viewDir = normalize(camera_position - frag_pos);
        vec3 reflectDir = reflect(-lightDir, normalize(normal));
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), material.shininess);
        vec3 specular = spec * light.specular_color * specular_color;

        ambient *= attenuation;
        diffuse *= attenuation;
        specular *= attenuation;

        result += ambient + diffuse + specular;
    }
    gl_FragColor = vec4(result, 1.0);
}
